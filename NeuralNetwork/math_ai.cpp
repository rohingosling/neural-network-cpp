//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// Class:	    MathAI
// Version:	    1.0
// Date:	    1998
// Author:	    Rohin Gosling
//
// Description:
//
//   General purpose static math functions, for use in AI and machine learning projects.
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <cmath>
#include <vector>
#include <random>

#include "math_ai.h"

using namespace std;


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Sigmoid
//  
//                  1
//            ────────────
//   f(x)  =  ╭       -x ╮
//            │  1 + e   │
//            ╰          ╯ 
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::Sigmoid ( double x )
{
    double ex = exp ( -x );
    double y  = 1.0 / (1.0 + ex);

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Parametric Sigmoid 
//  
//                   1
//            ──────────────
//   f(x)  =  ╭       -k·x ╮
//            │  1 + e     │
//            ╰            ╯  
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::sigmoid ( double x, double k )
{
    // Compute the sigmoid function.

    double ex = exp ( -k * x );
    double y  = 1.0 / ( 1.0 + ex );

    // Return the result.

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Sigmoid Derivative
//  
//                ╭              ╮            x
//                │      1       │           e
//             d  │ ──────────── │     ─────────────
//   f'(x)  =  ── │ ╭       -x ╮ │  =  ╭   x      ╮2
//             dx │ │  1 + e   │ │     │  e  + 1  │
//                │ ╰          ╯ │     ╰          ╯  
//                ╰              ╯
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::SigmoidDerivative ( double x )
{
    // Compute the derivitive of the sigmoid function.

    double ex   = exp ( x );
    double ex1  = ( ex + 1.0 );
    double dydx = ex / ex1 * ex1;

    // Return the result.

    return dydx;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Parametric Sigmoid Derivative
//  
//                ╭                ╮              k·x
//                │        1       │           k·e
//             d  │ ────────────── │     ───────────────
//   f'(x)  =  ── │ ╭       -k·x ╮ │  =  ╭   k·x      ╮2
//             dx │ │  1 + e     │ │     │  e    + 1  │
//                │ ╰            ╯ │     ╰            ╯  
//                ╰                ╯
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::SigmoidDerivative ( double x, double k )
{
    // Compute the derivitive of the sigmoid function.

    double ex   = exp ( k * x );
    double kex  = k * ex;
    double ex1  = ex + 1.0;    
    double dydx = kex / ex1 * ex1;

    // Return the result.

    return dydx;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Rectified Linear Unit
//                                  ╭
//                      x + │x│     │ x if x > 0
//   f(x)  =  R(x)  =  ────────  =  ┤ 
//                        2         │ 0 if x ≤ 0
//                                  ╰
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::ReLU ( double x )
{
    double y = ( x > 0.0 ) ? x : 0.0;

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Rectified Linear Unit Derivative
//                
//                ╭         ╮                 ╭
//             d  │ x + │x│ │     x + │x│     │ 1 if x > 0
//   f'(x)  =  ── │ ─────── │  =  ───────  =  ┤ 
//             dx │    2    │      2·│x│      │ 0 if x ≤ 0
//                ╰         ╯                 ╰
//                
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::ReLUDerivative ( double x )
{
    double dydx = ( x > 0 ) ? 1.0 : 0.0;

    return dydx;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//  
//  Hyperbolic Tangent
//  
//   f(x) = tanh(x)
//   
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::Tanh ( double x )
{
    double y = tanh ( x );

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Hyperbolic Tangent Derivative
//  
//             d  ╭         ╮             
//   f'(x)  =  ── │ tanh(x) │  =  1 - tanh²(x)
//             dx ╰         ╯   
//                              
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::TanhDerivative ( double x )
{
    double th   = tanh ( x );
    double dydx = 1.0 - th * th;

    return dydx;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Linear Polinomial
//  
//   f(x) = x
//   
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::Linear ( double x )
{
    double y = x;

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Linear Polinomial Derivative
//  
//             d  ╭   ╮             
//   f'(x)  =  ── │ x │  =  1
//             dx ╰   ╯   
//                              
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::LinearDerivative ( double x )
{
    double dydx = 1.0;

    return dydx;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Parametric Linear Polinomial
//  
//   f(x) = x
//   
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::Linear ( double x, double a )
{
    double y = a * x;

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Parametric Linear Polinomial
//  
//             d  ╭   ╮             
//   f'(x)  =  ── │ x │  =  1
//             dx ╰   ╯   
//                              
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::LinearDerivative ( double x, double a )
{
    double dydx = a;

    return dydx;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Truncated Sine Function (Sign function with periodic sine function)
//  
//             ╭
//             │  -1      if  x < -2·π
//             │
//   f(x)  =   ┤  sin(x)  if -2·π ≤ x ≤ 2·π
//             │
//             │   1      if  x >  2·π
//             ╰
//  
// Alternative definition.
//             
//             ╭
//             │  sin(x)  if -2·π ≤ x ≤ 2·π
//   f(x)  =   ┤  
//             │  sgn(x)  Otherwise
//             ╰            
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::Sinusoidal ( double x )
{
    const double pi  = 3.14159265358979323846;
    double       pi2 = 2 * pi;
    double       y   = 0.0;

    if ( ( x >= -pi2 ) && ( x <= pi2 ) )
    {
        y = sin ( x );
    }
    else if ( x < -pi2 )
    {
        y = -1.0;
    }
    else if ( x > pi2 )
    {
        y = 1.0;
    }

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Truncated Sine Function Derivative
//  
//              ╭
//              │  -1      if  x < -2·π
//              │
//   f'(x)  =   ┤  cos(x)  if -2·π ≤ x ≤ 2·π
//              │
//              │  -1      if  x >  2·π
//              ╰
//  
// Alternative definition.
//             
//             ╭
//             │  cos(x)  if -2·π ≤ x ≤ 2·π
//   f(x)  =   ┤  
//             │  -1      Otherwise
//             ╰   
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::SinusoidalDerivative ( double x )
{
    const double pi   = 3.14159265358979323846;
    double       pi2  = 2 * pi;
    double       dydx = ( ( x >= -pi2 ) && ( x <= pi2 ) ) ? cos ( x ) : -1.0;

    return dydx;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Hyperbolic Secant
//  
//                        1
//   y  =  sech(x)  =  ───────  
//                     cosh(x)
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::sech ( double x )
{
    // Compute hyperbolic secant.

    double y = 1.0 / cosh ( x );

    // Return the result.

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Sign Function (Signum Function) 
//  
//   y  =  sgn(x)
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::Sgn ( double x )
{
    // Declare local variables.

    double y = 0.0;

    // Compute the sign function.

    if ( x >  0.0 ) y =  1.0;
    if ( x <  0.0 ) y = -1.0;
    if ( x == 0.0 ) y =  0.0;

    // Return the result.

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Unit Step Function (Heaviside step function)
//  
//   y  =  step(x)
//  
// Alternative Form.
//  
//   y  =  H(x)
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::Step ( double x )
{
    // Declare local varaibles.

    double y = 0.0;

    // Compute the sign function.

    if ( x >  0.0 ) y = 1.0;
    if ( x <= 0.0 ) y = 0.0;

    // Return the result.

    return y;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// Vector Sum
//  
//     _      n
//   S(v)  =  ∑ ( vᵢ )
//           i=0 
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::VectorSum ( const Vector& v )
{
    // Declare local variables.

    double sum = 0.0;

    // Calculate sum.

    for ( double x : v )
    {
        sum += x;
    }

    // Return the result.

    return sum;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
// 
// HadamardProduct
//  
//   _    _   _
//   p  = u ◦ v
//  
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

MathAI::Vector MathAI::HadamardProduct ( const Vector& u, const Vector& v )
{
    // Declare local variables.

    Vector hp;
    double p;
    size_t u_size = u.size ();
    size_t v_size = v.size ();

    // Make sure the two vectors are the same size.

    if ( u_size == v_size )
    {
        // Calculate the Hadamard product of vectors u and v.
        
        size_t s = u_size;    // We can only rach this point in the code, if `u_size == v_size`. So we can pick any one of the vector sizes. 

        for ( size_t i = 0; i < s; ++i )
        {
            p = u [ i ] * v [ i ];

            hp.push_back ( p );
        }
    }
    else
    {
        // If the vectors are not of the same size, handle the error.
        // - In our case we are going to write and error message and return an empty vector.
        // - The vector will be empty because at this point we have not assigned it a value yet. 

        cout << endl << "[HadamardProduct] ERROR: Vectors must be of the same size." << endl;
    }

    // Return the result. 

    return hp;
}


//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Random Gaussian Distribution
//   
//   
//      x  =  rnd ( 0 ≤ x ≤ 1 )
//   
//   
//            1     1         3
//   f(x)  =  ─  +  ─ (2x - 1)
//            2     2
//      
// 
// Alternative form
// 
//                        3
//            1 + (2x - 1)
//   f(x)  =  ────────────
//                 2
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

double MathAI::GaussianDistribution ()
{
    // Initialize random number generator.

    random_device                      rd;
    mt19937                            random_generator    ( rd () );
    uniform_real_distribution <double> random_distribution ( 0.0, 1.0 );    

    // Compute gaussian distribution.

    double x        = random_distribution ( random_generator );
    double base     = 2.0 * x - 1;    
    double y        = ( 1.0 + base * base * base ) / 2.0;

    // Return the result.

    return y;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//      
//-------------------------------------------------------------------------------------------------------------------------------------------------------------